import numpy as np
import pandas as pd
import time

# Friends and their respective balance limits
friends = {
    'x': {'balance': 50, 'limit': 20},
    'y': {'balance': 70, 'limit': 50},
    'z': {'balance': 60, 'limit': 60},
    'v': {'balance': 80, 'limit': 70},
    'w': {'balance': 40, 'limit': 30}
}

# Generate random transactions
def generate_transaction():
    payee = np.random.choice(list(friends.keys()))
    payer = np.random.choice(list(friends.keys()) + ['external'])  # Can pay to external entity
    amount = np.random.randint(1, 30)  # Random amount between 1 and 30
    return payer, payee, amount

# Function to simulate a payment and generate recommendation
def make_payment(payer, payee, amount):
    if payer == 'external':
        if friends[payee]['balance'] + amount > 100:  # Avoiding overflows
            amount = 100 - friends[payee]['balance']
        friends[payee]['balance'] += amount
        print(f"{payee} received {amount} from external, new balance: {friends[payee]['balance']}")
    else:
        if friends[payer]['balance'] - amount < friends[payer]['limit']:  # Borrow if below limit
            deficit = friends[payer]['limit'] - (friends[payer]['balance'] - amount)
            if deficit > 0:
                borrow_from_others(payer, deficit)
            amount = min(amount, friends[payer]['balance'] - friends[payer]['limit'])
        
        friends[payer]['balance'] -= amount
        friends[payee]['balance'] += amount
        print(f"{payee} received {amount} from {payer}, new balance of {payee}: {friends[payee]['balance']}, new balance of {payer}: {friends[payer]['balance']}")

# Borrowing strategy when someone goes below their limit
def borrow_from_others(payer, deficit):
    print(f"{payer} needs to borrow {deficit}")
    lenders = sorted(friends.keys(), key=lambda x: friends[x]['balance'], reverse=True)
    for lender in lenders:
        if lender != payer and friends[lender]['balance'] > friends[lender]['limit']:
            available_funds = friends[lender]['balance'] - friends[lender]['limit']
            borrow_amount = min(deficit, available_funds)
            if borrow_amount > 0:
                friends[lender]['balance'] -= borrow_amount
                friends[payer]['balance'] += borrow_amount
                deficit -= borrow_amount
                print(f"{payer} borrowed {borrow_amount} from {lender}, new balance of {payer}: {friends[payer]['balance']}, new balance of {lender}: {friends[lender]['balance']}")
            if deficit <= 0:
                break

# Simulating transactions every second
def simulate_transactions(seconds=10):
    for _ in range(seconds):
        payer, payee, amount = generate_transaction()
        make_payment(payer, payee, amount)
        time.sleep(1)

# Start simulation for 10 seconds (you can increase the time)
simulate_transactions(10)

