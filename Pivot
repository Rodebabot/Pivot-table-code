import numpy as np
import time

# Friends and their respective balance limits
friends = {
    'x': {'balance': 50, 'limit': 20},
    'y': {'balance': 70, 'limit': 50},
    'z': {'balance': 60, 'limit': 60},
    'v': {'balance': 80, 'limit': 70},
    'w': {'balance': 40, 'limit': 30}
}

# Generate random transactions
def generate_transaction():
    payee = np.random.choice(list(friends.keys()))
    payer = np.random.choice(list(friends.keys()) + ['external'])  # Can pay to external entity
    amount = np.random.randint(1, 30)  # Random amount between 1 and 30
    return payer, payee, amount

# Function to simulate a payment and generate recommendation
def make_payment(payer, payee, amount):
    if payer == 'external':
        # External payments can only credit, no borrowing from external
        if friends[payee]['balance'] + amount > 100:  # Avoiding overflows
            amount = 100 - friends[payee]['balance']
        friends[payee]['balance'] += amount
        print(f"{payee} received {amount} from external, new balance: {friends[payee]['balance']}")
    else:
        # Check if the payer needs to borrow to maintain limit
        if friends[payer]['balance'] - amount < friends[payer]['limit']:  # Borrow if below limit
            deficit = friends[payer]['limit'] - (friends[payer]['balance'] - amount)
            if deficit > 0:
                borrow_from_others(payer, deficit)
            amount = min(amount, friends[payer]['balance'] - friends[payer]['limit'])
        
        # Perform the transaction if the payer has sufficient balance
        friends[payer]['balance'] -= amount
        friends[payee]['balance'] += amount
        print(f"{payee} received {amount} from {payer}, new balance of {payee}: {friends[payee]['balance']}, new balance of {payer}: {friends[payer]['balance']}")

# Borrowing strategy when someone goes below their limit
def borrow_from_others(payer, deficit):
    print(f"{payer} needs to borrow {deficit}")
    
    # Sort friends by available balance (descending)
    lenders = sorted(friends.keys(), key=lambda x: friends[x]['balance'] - friends[x]['limit'], reverse=True)
    
    for lender in lenders:
        if lender != payer and friends[lender]['balance'] > friends[lender]['limit']:
            available_funds = friends[lender]['balance'] - friends[lender]['limit']
            borrow_amount = min(deficit, available_funds)
            
            if borrow_amount > 0:
                # Transfer the funds from lender to payer
                friends[lender]['balance'] -= borrow_amount
                friends[payer]['balance'] += borrow_amount
                deficit -= borrow_amount
                print(f"{payer} borrowed {borrow_amount} from {lender}. New balance of {payer}: {friends[payer]['balance']}, New balance of {lender}: {friends[lender]['balance']}")
            
            if deficit <= 0:
                break

    # If deficit remains, print a warning
    if deficit > 0:
        print(f"{payer} could not borrow enough and still has a deficit of {deficit}.")

# Simulating transactions every second
def simulate_transactions(seconds=10):
    for _ in range(seconds):
        payer, payee, amount = generate_transaction()
        make_payment(payer, payee, amount)
        time.sleep(1)

    # Print final balances
    print("\nFinal Balances:")
    for friend, details in friends.items():
        print(f"{friend}: {details['balance']}")

# Start simulation for 10 seconds (you can increase the time)
simulate_transactions(10)
